package net.tarpn.frame;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;

import net.tarpn.config.Configs;
import net.tarpn.netty.network.NetRomDecoder;
import net.tarpn.network.netrom.NetRomNodes;
import net.tarpn.network.netrom.NetRomRoutingTable;
import net.tarpn.network.netrom.packet.NetRomPacket;
import net.tarpn.packet.impl.AX25PacketReader;
import net.tarpn.packet.impl.ax25.AX25Call;
import net.tarpn.packet.impl.ax25.AX25Packet;
import net.tarpn.packet.impl.ax25.UIFrame;
import org.junit.Test;

public class NetRomNodesTest {
  @Test
  public void testTarpnData() throws IOException {
    String[] nodesFiles = new String[] {
        "data/tadd-nodes-part-1.bin",
        "data/tadd-nodes-part-1.bin",
        //"data/doug-nodes.bin"
    };

    Configs configs = Configs.read("conf/sample.ini");
    NetRomRoutingTable router = new NetRomRoutingTable(configs.getNetRomConfig(),
            portNum -> configs.getPortConfigs().get(portNum), neighbor -> {});

    for(String nodeFile : nodesFiles) {
      byte[] packetBytes = Files.readAllBytes(Paths.get(nodeFile));
      AX25Packet packet = AX25PacketReader.parse(packetBytes);
      byte[] info = ((UIFrame)packet).getInfo();
      NetRomNodes nodes = NetRomNodes.read(info);
      router.updateNodes(packet.getSourceCall(), 1, nodes);
    }

    router.pruneRoutes();
    router.pruneRoutes();
    router.pruneRoutes();


    // find route for call
    /*
    AX25Call targetCall = AX25Call.create("N3LTV-2");
    Destination destination = router.getDestinations().get(targetCall);
    if(destination != null) {
      System.err.println("Found routes to " + targetCall);
      System.err.println(destination.getNeighbors());
      // loop through routes for this dest in order of quality
      // if there's an existing link to this neighbor, use it
      // if not, open a link and send the frame
    } else {
      System.err.println("No route to " + targetCall);
    }*/

    System.err.println(router.toPrettyString());

  }

  @Test
  public void testTarpn() {
    int[] data = new int[]{
            0x9c, 0x9e, 0x88, 0x8a, 0xa6, 0x40, 0xe0, 0x96,
            0x68, 0x88, 0x84, 0xb4, 0x40, 0x65, 0x03, 0xcf,
            0xff, 0x44, 0x41, 0x56, 0x49, 0x44, 0x20, 0x96,
            0x68, 0x88, 0x84, 0xb4, 0x40, 0x72, 0x5a, 0x44,
            0x42, 0x5a, 0x30, 0x39, 0x96, 0x68, 0x88, 0x84,
            0xb4, 0x40, 0x64, 0x5f, 0x96, 0x68, 0x88, 0x84,
            0xb4, 0x40, 0x62, 0x42, 0x42, 0x53, 0x20, 0x20,
            0x20, 0x96, 0x68, 0x88, 0x84, 0xb4, 0x40, 0x64,
            0x32, 0x96, 0x68, 0x88, 0x84, 0xb4, 0x40, 0x60,
            0x50, 0x49, 0x55, 0x53, 0x45, 0x52, 0x96, 0x68,
            0x88, 0x84, 0xb4, 0x40, 0x64, 0x46, 0x96, 0x9c,
            0x68, 0x9e, 0xa4, 0x84, 0x04, 0x41, 0x41, 0x52,
            0x4f, 0x4e, 0x4c, 0x96, 0x9c, 0x68, 0x9e, 0xa4,
            0x84, 0x64, 0xc8, 0x96, 0x9c, 0x68, 0x9e, 0xa4,
            0x84, 0x72, 0x5a, 0x4f, 0x52, 0x42, 0x30, 0x39,
            0x96, 0x9c, 0x68, 0x9e, 0xa4, 0x84, 0x64, 0x4a,
            0x96, 0x68, 0xa4, 0x8e, 0x9c, 0x40, 0x64, 0x54,
            0x49, 0x4c, 0x4c, 0x20, 0x20, 0x96, 0x9c, 0x68,
            0x9e, 0xa4, 0x84, 0x64, 0x7a, 0x96, 0x68, 0x96,
            0x88, 0x8a, 0x40, 0x64, 0x4b, 0x45, 0x56, 0x49,
            0x4e, 0x20, 0x96, 0x9c, 0x68, 0x9e, 0xa4, 0x84,
            0x64, 0x5f, 0x96, 0x86, 0x64, 0x84, 0xb0, 0x9c,
            0x64, 0x49, 0x41, 0x4e, 0x31, 0x20, 0x20, 0x96,
            0x9c, 0x68, 0x9e, 0xa4, 0x84, 0x64, 0x5f, 0x96,
            0x82, 0x64, 0x88, 0x8a, 0xae, 0x64, 0x54, 0x41,
            0x44, 0x44, 0x20, 0x20, 0x96, 0x9c, 0x68, 0x9e,
            0xa4, 0x84, 0x64, 0x9c, 0x9c, 0x66, 0x98, 0xa8,
            0xac, 0x40, 0x64, 0x44, 0x4f, 0x55, 0x47, 0x20,
            0x20, 0x96, 0x9c, 0x68, 0x9e, 0xa4, 0x84, 0x64,
            0x7a, 0x9c, 0x86, 0x68, 0x8c, 0x8e, 0x40, 0x64,
            0x46, 0x49, 0x4e, 0x20, 0x20, 0x20, 0x96, 0x9c,
            0x68, 0x9e, 0xa4, 0x84, 0x64, 0x7a
    };

    byte[] frame = new byte[data.length];
    for (int i = 0; i < frame.length; i++) {
      frame[i] = (byte)data[i];
    }

    AX25Packet packet = AX25PacketReader.parse(frame);
    System.err.println(packet);

    NetRomNodes nodes = NetRomNodes.read(((AX25Packet.HasInfo) packet).getInfo());
    System.err.println(nodes);

  }


  @Test
  public void testUnknown() {
    int[] data = new int[]{
            0x96, 0x9c, 0x68, 0x9e, 0xa4, 0x84, 0xe4, 0x96,
            0x68, 0x88, 0x84, 0xb4, 0x40, 0x65, 0xb6, 0xcf,
            0x96, 0x68, 0x88, 0x84, 0xb4, 0x40, 0x64, 0x96,
            0x9c, 0x68, 0x9e, 0xa4, 0x84, 0x72, 0x07, 0x0c,
            0xbd, 0x00, 0x06, 0x2f
    };

    byte[] frame = new byte[data.length];
    for (int i = 0; i < frame.length; i++) {
      frame[i] = (byte)data[i];
    }

    AX25Packet packet = AX25PacketReader.parse(frame);
    System.err.println(packet);

    //NetRomPacket netrom = NetRomDecoder.parseInfo((AX25Packet.HasInfo) packet);
    //System.err.println(netrom);
  }

  @Test
  public void testReadWrite() {
    NetRomNodes nodes = new NetRomNodes("TEST1", Arrays.asList(
            new NetRomNodes.NodeDestination(AX25Call.create("K4DBZ-1"), "BBS", AX25Call.create("K4DBZ-2"), 50),
            new NetRomNodes.NodeDestination(AX25Call.create("K4DBZ-9"), "ZDBZ09", AX25Call.create("K4DBZ-2"), 96)
    ));

    byte[] nodeBytes = NetRomNodes.write(nodes);
    NetRomNodes nodes2 = NetRomNodes.read(nodeBytes);

  }
}
